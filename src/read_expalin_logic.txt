Lines 370–401 are the tail end of your executeREAD implementation; here’s what they do step by step:

371:   std::stringstream ss(m[1].str());
372:   std::string tok;
373:   while (std::getline(ss, tok, ',')) {
374:     tok = std::regex_replace(tok, std::regex(R"(^\s+|\s+$)"), "");
375:     bool wantsString = (tok.back() == '$');
376:     std::string name = wantsString
377:                           ? tok.substr(0, tok.size() - 1)
378:                           : tok;
379: 
380:     if (program.dataPointer >= program.dataValues.size())
381:       throw std::runtime_error("RUNTIME ERROR: No more DATA");
382: 
383:     VarInfo val = program.dataValues[program.dataPointer++];
384:     if (wantsString) {
385:       // Allocate or fetch the VarInfo slot for this string var
386:       VarInfo &var = program.stringVariables[name];
387:       // Store the DATA value as a string
388:       var.stringValue = val.isString
389:                           ? val.stringValue
390:                           : std::to_string(val.numericValue);
391:       var.isString = true;
392:     } else {
393:       // Allocate or fetch the VarInfo slot for this numeric var
394:       VarInfo &var = program.numericVariables[name];
395:       // Store the DATA value as a number
396:       var.numericValue = !val.isString
397:                            ? val.numericValue
398:                            : std::stod(val.stringValue);
399:       var.isString = false;
400:     }
401:   }

    Lines 371–377 split and trim the comma-separated variable names, detect trailing $, and strip it off for string variables.

    Line 380 checks you haven’t run out of DATA values, throwing an error if you have.

    Lines 383–392 handle the string branch: they grab the next VarInfo from program.dataValues, then set .stringValue (and mark isString=true) in program.stringVariables[name].

    Lines 393–401 handle the numeric branch: similarly storing .numericValue (and isString=false) in program.numericVariables[name].

